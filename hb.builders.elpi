/*        Hierarchy Builder: algebraic hierarchies made easy
    This software is released under the terms of the MIT license              */

%%%%%%% Naming converntions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*
   - under-foobar.do! Arg [ Code ]
     enriches the context with foobar, the runs std.do! [ Code ]
   - under-foobar.then Arg F Out
     enriches the context with foobar, the runs F Out, as a consequence
     the spilling expression {under-foobar.then Arg F} can be used
   - foo_bar
     projection from foo to its field bar
   - foo->bar
     conversion from type foo to type bar (it can be arbitrarily complex)
   - get-foobar
     reads foobar from the Coq world
   - findall-foobar
     reads foobar from hb.db, the output is sorted whenever it makes sense
   - main-foobar
     main entry point for a user facing (or almost user facing) command foobar
   - declare-foobar
     predicate adding to the Coq ennvironment a foobar
   - postulate-foobar
     predicate assuming a foobar (declaring a Coq section variable)
   - TheType, TheClass, TheFoobar
     the thing the current code is working on, eg the type of the structure
     begin defined
   - FooAlias
     see phant-abbrev, used to talk about the non canonical name of Foo
   - when foo is the constructor of a data type with type A1 -> .. -> AN -> t
     we define mk-foo as:
       mk-foo A1 .. AN (foo A1 .. AN)
*/

accumulate hb-utils.
accumulate hb-coq-vernac.
accumulate hb-database.
accumulate hb-synthesis.
accumulate hb.context.
accumulate hb.export.

shorten coq.{ term->gref, subst-fun, safe-dest-app, mk-app, mk-eta, subst-prod }.


% [main-declare-builder (builder _ F M B) From MoreFrom] Given B of type FB, it
% declares all the new builders F to M via B.
% From holds the (from F Mi Bi) new clauses during folding.
pred main-declare-builder i:builder, i:list prop, o:list prop.
main-declare-builder (builder _ SrcFactory TgtMixin B) FromClauses MoreFromClauses :-
  FromClauses => std.do! [
    if (from SrcFactory TgtMixin _)
       (if-verbose (coq.say "HB: skipping duplicate builder from"
          {nice-gref->string SrcFactory} "to" {nice-gref->string TgtMixin}),
        MoreFromClauses = FromClauses)
       (if-verbose (coq.say "HB: declare builder from"
          {nice-gref->string SrcFactory} "to" {nice-gref->string TgtMixin}),
        MoreFromClauses = [from SrcFactory TgtMixin B|FromClauses])
  ].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HB.builders
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred declare-old-located i:string, i:located.
declare-old-located Id (loc-gref GR) :-
  @global! => coq.vernac.add-abbreviation Id 0 (global GR) ff _.
declare-old-located Id (loc-abbreviation Abbrev) :-
  coq.notation.abbreviation Abbrev [] T,
  % FIXME: this assumes the abbreviation has no arg
  % we should fix it.
  @global! => coq.vernac.add-abbreviation Id 0 T ff _.

pred declare-old-constant i:option constant.
declare-old-constant none.
declare-old-constant (some C) :-
  coq.gref->id (const C) Id,
  std.forall {coq.locate-all Id} (declare-old-located Id).
declare-old-constant _ :- true.

pred elaborate-context-skel->factory i:context-decl, o:context-decl, o:factoryname, o:diagnostic.
elaborate-context-skel->factory
  (context-item IDT IT TTySkel none t\ context-item IDF IF (TFSkel t) none _\ context-end)
  (context-item IDT IT TTy none t\ context-item IDF IF (TFSkel t) none _\ context-end) GRF Diag
:- !, std.do-ok! Diag [
  coq.elaborate-ty-skeleton TTySkel _ TTy,
  (d\ coq.id->name IDT NameT),
  (d\ @pi-decl NameT TTy t\ purge-id (TFSkel t) (TFSkel1 t), coq.elaborate-ty-skeleton (TFSkel1 t) _ (TF1 t) d),
  (d\ @pi-decl NameT TTy t\ std.assert! (factory? (TF1 t) (triple GRF _Params t)) "the last argument must be a factory applied to the type variable"),
].
elaborate-context-skel->factory (context-item ID I TSkel none C) (context-item ID I T none C1) GRF Diag :- !, std.do-ok! Diag [
  coq.elaborate-ty-skeleton TSkel _ T,
  (d\ coq.id->name ID Name),
  (d\ @pi-decl Name T x\ elaborate-context-skel->factory (C x) (C1 x) GRF d),
].
elaborate-context-skel->factory (context-item ID _ _ (some _) _) _ _ _ :-
  coq.error "context item cannot be given a body:" ID.

pred postulate-factory-abbrev i:term, i:list term, i:id, i:factoryname, o:term.
postulate-factory-abbrev TheType Params Name Falias TheFactory :- std.do! [
  factory-alias->gref Falias F,
  phant-abbrev F _ Fabv,
  coq.notation.abbreviation Fabv {std.append Params [TheType]} Package,
  Msg is "Unable to declare factory " ^ Name,
  std.assert-ok! (coq.typecheck-ty Package _) Msg,
  coq.vernac.add-variable Name Package C,
  TheFactory = global (const C),
].

% Only record fields can be exported as operations.
pred define-factory-operations i:term, i:list term, i:term, i:gref.
define-factory-operations TheType Params TheFactory (indt I) :- !,
  coq.env.indt I _ NIParams _ _ _ _,
  NHoles is NIParams - 1 - {std.length Params},
  coq.CS.canonical-projections I PL,
  std.forall PL (define-factory-operation TheType Params TheFactory NHoles).
define-factory-operations _ _ _ _.

pred define-factory-operation i:term, i:list term, i:term, i:int, i:option constant.
define-factory-operation _ _ _ _ none.
define-factory-operation TheType Params TheFactory NHoles (some P) :-
  coq.mk-n-holes NHoles Holes,
  std.append Holes [TheFactory] Holes_Factory,
  std.append Params [TheType|Holes_Factory] Args,
  T = app[global (const P)|Args],
  std.assert-ok! (coq.typecheck T _) "Illtyped applied factory operation",
  coq.gref->id (const P) Name,
  @local! => coq.vernac.add-abbreviation Name 0 T ff _.

pred fresh-type o:term.
fresh-type Ty :-
  Ty = {{Type}},
  std.assert-ok! (coq.typecheck-ty Ty _) "impossible".

pred builders-postulate-factories i:id, i:context-decl.
builders-postulate-factories ModName (context-item IDT _ TySkel none t\ context-item IDF _ (TF t) none _\ context-end) :- !, std.do! [
  % TODO we should allow T to be anything.
  std.assert-ok! (coq.elaborate-ty-skeleton TySkel _ Ty) "builders-postulate-factory: illtyped context",
  if (var Ty) (fresh-type Ty)
     (std.assert-ok! (coq.unify-eq Ty {{Type}}) "The last context item before the factory must be a type variable"),
  if-verbose (coq.say "HB: postulating type" IDT),
  coq.vernac.add-variable IDT Ty C,
  TheType = global (const C),

  std.assert! (factory? (TF TheType) (triple GRF Params TheType))
    "the last argument must be a factory applied to the type variable",
  gref-deps GRF GRFMLwP, % TODO: remove, pass to main-declare-context the list-w-params-eta-expansion of GRF
  main-declare-context TheType Params GRFMLwP _ _,
  postulate-factory-abbrev TheType Params IDF GRF TheFactory,
  define-factory-operations TheType Params TheFactory GRF,
  coq.vernac.accumulate current (clause _ _ (current-mode (builder-from TheFactory GRF ModName))),
].

builders-postulate-factories ModName (context-item ID _ TSkel none Factories) :- std.do! [
  if-verbose (coq.say "HB: postulating" ID),
  std.assert-ok! (coq.elaborate-ty-skeleton TSkel _ T) "builders-postulate-factories: illtyped context",
  if (var T) (coq.fresh-type T) true,
  coq.vernac.add-variable ID T P,
  TheParam = global (const P),
  builders-postulate-factories ModName (Factories TheParam),
].

builders-postulate-factories _ (context-item ID _ _ (some _) _) :-
  coq.error "context item cannot be given a body:" ID.

pred main-begin-declare-builders i:context-decl.
main-begin-declare-builders CtxSkel :- std.do! [
  Name is "Builders_" ^ {term_to_string {new_int}}, % TODO?
  std.assert-ok! (elaborate-context-skel->factory CtxSkel Ctx GRF) "Context illtyped",
  if-verbose (coq.say "HB: context to factory"),
  coq.vernac.begin-module Name,
  if-verbose (coq.say "HB: begin module for builders"),
  if (GRF = indt FRecord) (std.do! [
    if-verbose (coq.say "HB: begin module Super"),
    coq.vernac.begin-module "Super",
    std.forall {coq.CS.canonical-projections FRecord} declare-old-constant,
    coq.vernac.end-module "Super" _,
    if-verbose (coq.say "HB: ended module Super")]) (true),
  coq.vernac.begin-section Name,
  if-verbose (coq.say "HB: postulating factories"),
  builders-postulate-factories Name Ctx,
].

/* HB.context?
pred main-begin-declare i:string, i:string, i:list gref, i:declaration.
main-begin-declare Module TName GRFS Decl :- std.do! [

  if-verbose (coq.say "HB: start module and section" Module),

  coq.vernac.begin-module Module none,
  coq.vernac.begin-section Module,

  if-verbose (coq.say "HB: postulate type" TName),

  coq.fresh-type Ty,
  @local! => coq.vernac.add-const TName _ Ty @opaque! T, % no body, local -> a variable
  main-declare-context (global (const T)) [] GRFS _, % TODO params
  coq.vernac.accumulate current (clause _ _ (current-mode Decl))
].
*/

pred main-end-declare-builders.
main-end-declare-builders :- std.do! [
  current-mode (builder-from _ GR ModName),

  coq.vernac.end-section ModName,

  findall-builders LFIL,

  std.fold LFIL [] main-declare-builder Clauses,

  if (Clauses = [])
     (coq.error "No builders to declare, did you forget HB.instance?")
     true,

  % TODO: Do we need this module?
  gref->modname GR M,
  Name is M ^ "_Exports",
  coq.vernac.begin-module Name,
  (std.forall Clauses c\ coq.vernac.accumulate current (clause _ _ c)),

  coq.vernac.end-module Name Exports,
  coq.vernac.end-module ModName _,
  hb.export Exports,
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HB.mixin/factory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

