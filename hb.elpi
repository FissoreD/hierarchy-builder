/*        Hierarchy Builder: algebraic hierarchies made easy
    This software is released under the terms of the MIT license              */

%%%%%%% Naming converntions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*
   - under-foobar.do! Arg [ Code ]
     enriches the context with foobar, the runs std.do! [ Code ]
   - under-foobar.then Arg F Out
     enriches the context with foobar, the runs F Out, as a consequence
     the spilling expression {under-foobar.then Arg F} can be used
   - foo_bar
     projection from foo to its field bar
   - foo->bar
     conversion from type foo to type bar (it can be arbitrarily complex)
   - get-foobar
     reads foobar from the Coq world
   - findall-foobar
     reads foobar from hb.db, the output is sorted whenever it makes sense
   - main-foobar
     main entry point for a user facing (or almost user facing) command foobar
   - declare-foobar
     predicate adding to the Coq ennvironment a foobar
   - postulate-foobar
     predicate assuming a foobar (declaring a Coq section variable)
   - TheType, TheClass, TheFoobar
     the thing the current code is working on, eg the type of the structure
     begin defined
   - FooAlias
     see phant-abbrev, used to talk about the non canonical name of Foo
   - when foo is the constructor of a data type with type A1 -> .. -> AN -> t
     we define mk-foo as:
       mk-foo A1 .. AN (foo A1 .. AN)
*/

accumulate hb-utils.
accumulate hb-coq-vernac.
accumulate hb-database.
accumulate hb-synthesis.
accumulate hb.instance.

shorten coq.{ term->gref, subst-fun, safe-dest-app, mk-app, mk-eta, subst-prod }.


%%%%% HB Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Type to share code between HB.mixin and HB.factory (that supports alias factories)
kind asset type.
type asset-mixin asset.
type asset-factory asset.

kind asset-decl type.
type asset-parameter  id -> term -> (term -> asset-decl) -> asset-decl.
type asset-record     id -> term -> id -> record-decl    -> asset-decl.
type asset-alias      id -> term                         -> asset-decl.

pred name-of-asset-decl i:asset-decl, o:string.
name-of-asset-decl (asset-parameter _ _ R) X :-
  pi x\ name-of-asset-decl (R x) X.
name-of-asset-decl (asset-record X _ _ _) X.
name-of-asset-decl (asset-alias X _) X.

pred argument->asset i:argument, o:asset-decl.
argument->asset (indt-decl (parameter ID _ImplicitStatus TySkel I)) (asset-parameter ID Ty A) :- !,
  % Should we check that _ImplicitStatus is explicit?
  coq.string->name ID Name,
  std.assert-ok! (coq.elaborate-ty-skeleton TySkel _ Ty) "parameter illtyped",
  @pi-decl Name Ty a\
    argument->asset (indt-decl (I a)) (A a).
argument->asset (indt-decl (record Rid Ty Kid F)) (asset-record Rid Ty Kid F) :- !.
argument->asset (const-decl Id (some (fun _ _ Bo)) (parameter ID _ SrcSkel Ty)) (asset-parameter ID Src A) :- !,
  coq.id->name ID Name,
  std.assert-ok! (coq.elaborate-ty-skeleton SrcSkel _ Src) "parameter illtyped",
  @pi-decl Name Src a\
    argument->asset (const-decl Id (some (Bo a)) (Ty a)) (A a).
argument->asset (const-decl Id (some Bo) (arity Ty)) (asset-alias Id Bo) :- !,
  std.assert! (var Ty) "Factories aliases should not be given a type".
argument->asset X _ :- coq.error "Unsupported asset:" X.

pred append-phant-unify i:phant-term, o:phant-term.
append-phant-unify (phant-term LP T) (phant-term LPU T) :-
  std.append LP [unify-arg] LPU.



% phant %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Notations /Ã  la/ *pack* are always of the shape
% [Notation N x_0 .. x_n := C x_0 .. _ _ id .. x_i .. _ id _ _ id]
% with a variable number of [_] between each [id], and where
% - [x_i] is given by the user
% - [_]   correspond to arguments that are left implicit,
% - [id]  trigger unification as described in
% /Canonical Structures for the working Coq user/ by Mahboubi and Tassi
%
% phant-arg encode these three kind of arguments
% - [x_i] is encoded using [real-arg x_i]
% - [_]              using [implicit-arg]
% - [id]             using [unify-arg]
kind phant-arg type.
type real-arg name -> phant-arg.
type infer-type name -> phant-arg.
type implicit-arg phant-arg.
type unify-arg phant-arg.

% phant-term is a pair of a list of argument kinds together with a term
kind phant-term type.
type phant-term list phant-arg -> term -> phant-term.

pred phant-fun i:phant-arg, i:term, i:(term -> phant-term), o:phant-term.
phant-fun Arg Ty PhF (phant-term [Arg|ArgL] (fun N Ty F)) :-
  if (Arg = real-arg N) true (N = `_`),
  @pi-decl N Ty x\ PhF x = phant-term ArgL (F x).

pred phant-fun-real i:name, i:term, i:(term -> phant-term), o:phant-term.
phant-fun-real N T F Res :- !, phant-fun (real-arg N) T F Res.

% [phant-fun-unify N X1 X2 PF PUF] states that PUF is a phant-term that
% is starts with unifing X1 and X2 and then outputs PF.
% N is ignored
pred phant-fun-unify i:term, i:term, i:term, i:phant-term, o:phant-term.
phant-fun-unify Msg X1 X2 (phant-term AL F) (phant-term [unify-arg|AL] UF) :-
  std.assert-ok! (coq.typecheck X1 T1) "phant-fun-unify: X1 illtyped",
  std.assert-ok! (coq.typecheck X2 T2) "phant-fun-unify: X2 illtyped",
  UF = {{fun unif_arbitrary : lib:hb.unify lp:T1 lp:T2 lp:X1 lp:X2 lp:Msg => lp:F}}.

% [phant-fun-implicit N Ty PF PUF] states that PUF is a phant-term
% which quantifies [PF x] over [x : Ty] (with name N)
pred phant-fun-implicit i:name, i:term, i:(term -> phant-term), o:phant-term.
phant-fun-implicit N Ty PF (phant-term [implicit-arg|AL] (fun N Ty F)) :- !,
  @pi-decl N Ty t\ PF t = phant-term AL (F t).

pred phant-fun-unify-mixin i:term, i:name, i:term, i:(term -> phant-term), o:phant-term.
phant-fun-unify-mixin T N Ty PF Out :- !, std.do! [
  safe-dest-app Ty (global M) _,
  Msg is "phant-fun-unify-mixin: No mixin-src on " ^ {coq.term->string T},
  std.assert! (mixin-src T M Msrc) Msg,
  (@pi-decl `m` Ty m\ phant-fun-unify {{lib:hb.nomsg}} m Msrc (PF m) (PFM m)),
  phant-fun-implicit N Ty PFM Out
].

% [phant-fun-struct T S Params PF PSF] states that PSF is a phant-term
% which postulate a structure [s : S Params] such that [T = sort s]
% and then outputs [PF s]
pred phant-fun-struct i:term, i:name, i:structure, i:list term, i:(term -> phant-term), o:phant-term.
phant-fun-struct T Name S Params PF Out :- std.do! [
  get-structure-sort-projection S SortProj,
  mk-app (global S) Params SParams,
  mk-app SortProj Params SortProjParams,
  % Msg = {{lib:hb.nomsg}},
  Msg = {{lib:hb.some (lib:hb.pair lib:hb.not_a_msg lp:SParams)}},
  (@pi-decl Name SParams s\ phant-fun-unify Msg T {mk-app SortProjParams [s]} (PF s) (UnifSI s)),
  phant-fun-implicit Name SParams UnifSI Out
].


% ----------- Finding and instantiating mixin arguments -------------------

pred prod-src-is-factory i:term.
prod-src-is-factory (prod _ S _) :- factory? S _.
prod-src-is-factory Ty :- whd1 Ty Ty1, !, prod-src-is-factory Ty1.

% [find-max-classes Mixins Classes] states that Classes is a list of classes
%   which contain all the mixins in Mixins.
% Although it is not strictly necessary, but desirable for debugging,
% we use a heuristic that tries to minimize the number
% of classes by assuming Mixins are reversed topologically sorted.
% Note: works with flat mixins, no params
pred find-max-classes i:list mixinname, o:list classname.
find-max-classes [] [].
find-max-classes [M|Mixins] [C|Classes] :-
  mixin-first-class M C,
  std.do! [
    class-def (class C _ MLwP),
    list-w-params_list MLwP ML,
    std.filter Mixins (x\ not (std.mem! ML x)) Mixins',
    find-max-classes Mixins' Classes
  ].
find-max-classes [M|_] _ :- coq.error "HB: cannot find a class containing mixin" M.

pred under-mixins.then i:list (w-args mixinname),
    i:(name -> term -> (term -> A) -> A -> prop),
    i:(A -> prop), o:A.
under-mixins.then [] _ Pred Body :- !, Pred Body.
under-mixins.then [triple M Args T|ML] Mixin Pred Out :- std.do! [
  mgref->term Args T M MTy,
  (@pi-decl `m` MTy m\ mixin-src T M m =>
    under-mixins.then ML Mixin Pred (Body m)),
  Mixin `m` MTy Body Out,
].

% [mk-mixin-fun.then MLwP Pred F] states that F has shape
%   fun p_1 .. p_k T,
%      (m_0 : M_0 ..p.. T) .. (m_n : M_n ..p.. T m_i0 .. m_ik) =>
%      Body m_0 .. m_n
% where  MLwP contains M_0, .., M_n (under p_1 .. p_k)
%   and  Body is such that [..,mixin-src T M_i m_i,..] => Pred Body
%   and  ..p.. is a list of terms built using p_1 .. p_k and T
pred mk-mixin-fun.then i:list-w-params mixinname, i:(list term -> term -> term -> prop), o:term.
mk-mixin-fun.then L P Out :- !,
  w-params.then L mk-fun mk-fun
    (p\ t\ ml\ under-mixins.then ml mk-fun (P p t)) Out.

% A *pack* notation can be easiliy produced from a phant-term using
% [mk-phant-abbrev N PT C], which states that C is a new constant
% which name is phant_N, and which produces a simple notation
% with name N using the data of the phant-term PT to reconstruct a notation
% [Notation N x0 .. xn := C x0 _ _ id .. xi .. _ id _ _ id]
% as described above.
pred mk-phant-abbrev.term i:int, i:term, i:list phant-arg, o:int, o:term.
mk-phant-abbrev.term K F [] K F.
mk-phant-abbrev.term K F [real-arg N|AL] K'' (fun N _ AbbrevFx) :- !,
  pi x\ mk-phant-abbrev.term K {mk-app F [x]} AL K' (AbbrevFx x),
  K'' is K' + 1.
mk-phant-abbrev.term K F [infer-type N|AL] K'' (fun N _ AbbrevFx) :- !,
  pi x\ mk-phant-abbrev.term K {mk-app F [{{ lib:hb.Phant lp:x }}]} AL K' (AbbrevFx x),
  K'' is K' + 1.
mk-phant-abbrev.term K F [implicit-arg|AL] K' FAbbrev :- !,
  mk-phant-abbrev.term K {mk-app F [_]} AL K' FAbbrev.
mk-phant-abbrev.term K F [unify-arg|AL] K' FAbbrev :- !,
  mk-phant-abbrev.term K {mk-app F [{{lib:@hb.id _ _}}]} AL K' FAbbrev.

pred mk-phant-abbrev i:string, i:phant-term, o:constant, o:abbreviation.
mk-phant-abbrev N (phant-term AL T1) C Abbrev :- std.do! [
  NC is "phant_" ^ N,
  std.assert-ok! (coq.elaborate-skeleton T1 TTy T) "mk-phant-abbrev: T illtyped",
  coq.vernac.add-const NC T TTy @transparent! C,
  mk-phant-abbrev.term 0 (global (const C)) AL NParams AbbrevT,
  @global! => coq.vernac.add-abbreviation N NParams AbbrevT tt Abbrev,
].

% [acc-phant-abbrev Str GR PhGR Abbrev] makes a phantom abbreviation for F
pred acc-phant-abbrev i:string, i:gref, o:gref, o:abbreviation.
acc-phant-abbrev Str GR (const PhC) Abbrev :- !, std.do! [
  mk-phant-term GR PhGR,
  mk-phant-abbrev Str PhGR PhC Abbrev
].

% [phant-fun-mixin N Ty PF PUF] states that PUF is a phant-term
% which quantifies [PF x] over [x : Ty] (with name N)
% Ty must be an (applied) mixin M, and the phantom status of this mixin
% is determined by [phant-mixin-real M].
pred phant-mixin-real o:mixinname.
pred phant-fun-mixin i:name, i:term, i:(term -> phant-term), o:phant-term.
phant-fun-mixin N Ty PF (phant-term [Status|AL] (fun N Ty F)) :- !, std.do! [
  @pi-decl N Ty t\ PF t = phant-term AL (F t),
  safe-dest-app Ty (global Mixin) _,
  if (phant-mixin-real Mixin) (Status = real-arg N) (Status = implicit-arg)
].

% [mk-phant-term F PF] states that
% if F = fun p1 .. p_k T m_0 .. m_n => _
% then PF = phant-term
%   [real-arg p_1, ... real-arg p_k, real-arg T, implicit-arg, .., implicit-arg,
%       implicit-arg, .., implicit-arg,
%         implicit-arg, unify-arg,
%         implicit-arg, unify-arg,
%         implicit-arg, .., implicit-arg, unify-arg,
%         unify-arg, ..., unify-arg,
%       ...,
%       implicit-arg, .., implicit-arg,
%         implicit-arg, unify-arg,
%         implicit-arg, unify-arg,
%         implicit-arg, .., implicit-arg, unify-arg,
%         unify-arg, ..., unify-arg]
%   {{fun p_1 ... p_k T m_0 .. m_n =>
%       fun q_1 .. q_l =>
%         [find s_0 | T ~ s_0]
%         [find c_0 | s_0 ~ SK q_1 .. q_l T c_0]
%         [find m'_{i_0_0}, .., m'_{i_0_n0} | c_0 ~ CK m'_{i_0_0} .. m'_{i_0_n0}]
%         fun of hb.unify m_{i_0_0} m'_{i_0_0} & ... & hb.unify m_{i_0_n0} m'_{i_0_n0} =>
%       ...
%       fun q'_1 .. q'_l' =>
%         [find s_k | T ~ s_k]
%         [find c_k | s_k ~ SK q'_1 .. q'_l' T c_k]
%         [find m'_{i_k_0}, .., m'_{i_k_nk} | c_0 ~ CK m'_{i_k_0} .. m'_{i_k_nk}]
%         fun of hb.unify m_{i_0_0} m'_{i_0_0} & ... & hb.unify m_{i_k_nk} m'_{i_k_nk} =>
%       F p_1 ... p_k T m_i0_j0 .. m_il_jl}}
pred mk-phant-term.mixins i:term, i:classname, i:phant-term,
  i:list term, i:name, i:term, i:(term -> list (w-args mixinname)), o:phant-term.
mk-phant-term.mixins T CN PF Params N Ty MLwA Out :- std.do! [
  class-def (class CN SI _),
  mk-app (global SI) Params SIParams,
  NoMsg = {{lib:hb.nomsg}},
  coq.name-suffix N "local" Nlocal,
  (@pi-decl Nlocal Ty t\ sigma SK KC ML\ std.do! [
    std.map (MLwA t) triple_1 ML,
    std.append Params [T] ParamsT,
    SKPT = app [global {get-constructor SI} | ParamsT],
    ClassTy = app [global CN | ParamsT],
    (@pi-decl `s` SIParams s\ @pi-decl `c` ClassTy c\ sigma PF2\ std.do![
       under-mixins.then (MLwA t) (phant-fun-unify-mixin T) (mk-phant-term.mixins.aux t Params c CN PF) PF2,
       phant-fun-unify NoMsg s {mk-app SKPT [c]} PF2 (PFU t s c)])
  ]),
  Out = {phant-fun-struct T `s` SI Params s\
          {phant-fun-implicit `c` ClassTy (PFU T s)}}
].

mk-phant-term.mixins.aux T Params C CN PF X :- std.do![
  get-constructor CN KC,
  mgref->term Params T KC KCM,
  phant-fun-unify {{lib:hb.nomsg}} KCM C PF X,
].

pred mk-phant-term.class i:term, i:classname, i:phant-term, o:phant-term.
mk-phant-term.class T CN PF CPF :- !, std.do! [
  class-def (class CN _ CMLwP),
  w-params.fold CMLwP phant-fun-implicit (mk-phant-term.mixins T CN PF) CPF
].

pred mk-phant-term.classes i:term, i:list classname, i:list term, i:term,
                      i:list (w-args mixinname), o:phant-term.
mk-phant-term.classes EtaF CNF PL T MLwA PhF :- !, std.do! [
  std.map MLwA triple_1 ML,
  under-mixins.then MLwA phant-fun-mixin (out\ sigma FPLTM\ std.do! [
    mterm->term (mterm PL T ML EtaF) FPLTM,
    std.fold CNF (phant-term [] FPLTM) (mk-phant-term.class T) out]) PhF
].

pred mk-phant-term i:gref, o:phant-term.
mk-phant-term GRF PhBody:- !, std.do! [
  std.assert! (gref-deps GRF MLwP) "mk-phant-term: unknown gref",
  std.assert! (coq.env.typeof GRF FTy) "mk-phant-term: F illtyped",
  mk-eta (-1) FTy (global GRF) EtaF,
%  toposort-mixins ML MLSorted,
  MLwP = MLwPSorted, % Assumes we give them already sorted in dep order.
  std.rev {list-w-params_list MLwPSorted} MLSortedRev,

  % phant-mixin-real is used to tag mixins which are passed as arguments
  std.filter MLSortedRev (m\not(phant-mixin-real m)) MLSortedRevFiltered,
  find-max-classes MLSortedRevFiltered CNL,
  assert-good-coverage! MLSortedRevFiltered CNL,

  w-params.then MLwP phant-fun-real phant-fun-real
    (mk-phant-term.classes EtaF CNL) PhBody,
].

pred classname->mixins i:classname, o:list-w-params mixinname.
classname->mixins CN MLwP :- class-def (class CN _ MLwP).

pred class-coverage i:list classname, o:coq.gref.set.
class-coverage CNL CSet :-
  std.map CNL classname->mixins CMLLwP,
  std.map CMLLwP list-w-params_list CMLL,
  coq.gref.list->set {std.flatten CMLL} CSet.

pred coq.gref.list->set i:list mixinname, o:coq.gref.set.
coq.gref.list->set L S :-
  std.fold L {coq.gref.set.empty} coq.gref.set.add S.

pred assert-good-coverage! i:list mixinname, i:list classname.
assert-good-coverage! MLSortedRev CNL :- std.do! [
  coq.gref.list->set MLSortedRev MLSet,
  class-coverage CNL CMLSet,
  if (not(coq.gref.set.equal MLSet CMLSet))
     (coq.gref.set.diff CMLSet MLSet Extra,
      coq.error "I could not find classes covering exactly mixins:"
        {std.any->string MLSortedRev}
        "In particular the covering" CNL "also includes mixins:"
        {coq.gref.set.elements Extra}
        "This should never happen, please report a bug.")
     true
].

pred if-coverage-not-good-error i:list mixinname.
if-coverage-not-good-error ML :-
  coq.gref.list->set ML MS,
  std.forall ML (if-coverage-not-good-error.one MS).

pred if-coverage-not-good-error.one i:coq.gref.set, i:mixinname.
if-coverage-not-good-error.one MS M :- mixin-first-class M C, !,
  class-coverage [C] CMS,
  if (coq.gref.set.subset CMS MS)
     true
     (coq.gref.set.elements {coq.gref.set.remove M CMS} MissinFromCurrent,
      coq.error "HB: the first structure declared in this hierarchy containing" {nice-gref->string M} "is" {nice-gref->string C}
       "which also contains" {std.map MissinFromCurrent nice-gref->string} "."
       "\nThe are two ways to fix this problem:"
       "1) change the current structure to contain" {std.map MissinFromCurrent nice-gref->string} "as well;"
       "2) amend the hierarchy by declaring a structure before" {nice-gref->string C}
       "which contains at most" {std.map {coq.gref.set.elements {coq.gref.set.inter CMS MS}} nice-gref->string}).
if-coverage-not-good-error.one _ _. % new class is the first covering M


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              Synthesis                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



kind factory-abbrev type.
type factory-by-classname gref -> factory-abbrev.
type factory-by-phantabbrev abbreviation -> factory-abbrev.

pred declare-factory-abbrev i:id, i:factory-abbrev.
declare-factory-abbrev Name (factory-by-classname GR) :-
  % looks fishy (the parameters are not taken into account)
  @global! => coq.vernac.add-abbreviation Name 1 (fun _ _ t\ app[global GR,t]) tt _.
declare-factory-abbrev Name (factory-by-phantabbrev Abbr) :- std.do! [
  coq.notation.abbreviation-body Abbr Nargs AbbrTrm,
  @global! => coq.vernac.add-abbreviation Name Nargs AbbrTrm tt _,
].

% [mk-factory-abbrev Str GR CL FactAbbrev]
% creates an abbreviation for GR names Str and creates a phant-abbrev clause in CL.
% FactAbbrev is the short name for the factory (either an alias of the class record)
pred mk-factory-abbrev i:string, i:gref, o:list prop, o:factory-abbrev.
mk-factory-abbrev Str GR Aliases FactAbbrev :- !, std.do! [
  if (factory-alias->gref GR _)
     (Aliases = [],
      FactAbbrev = factory-by-classname GR)
     (acc-phant-abbrev Str GR PhGR Abbrv,
      Aliases = [phant-abbrev GR PhGR Abbrv],
      FactAbbrev = factory-by-phantabbrev Abbrv),
].

% The identity builder
pred declare-id-builder i:factoryname, o:prop.
declare-id-builder GR (from GR GR (const C)) :- std.do! [
  mk-mixin-fun.then {gref-deps GR}
    (params\ t\ body\ sigma MTy\
      mgref->term params t GR MTy,
      body = fun `x` MTy x\x)
    IDBody,
  std.assert-ok! (coq.typecheck IDBody IDType) "identity builder illtyped",
  coq.vernac.add-const "identity_builder" IDBody IDType @transparent! C,
].


% Given a type T, a fresh number N, and a mixin M it postulates
% a variable "mN" inhabiting M applied to T and
% all its dependencies, previously postulated and associated
% to the corresponding mixin using mixin-for
pred postulate-mixin i:w-args mixinname, i:list prop, o:list prop.
postulate-mixin (triple M Ps T) MSL [mixin-src T M (global (const C))|MSL] :- MSL => std.do! [
  Name is "mixin_" ^ {gref->modname M},

  if-verbose (coq.say "HB: postulate" Name "on" {coq.term->string T}),

  mgref->term Ps T M Ty,
  std.assert-ok! (coq.typecheck Ty _) "postulate-mixin: Ty illtyped",
  coq.vernac.add-variable Name Ty C
].

% [main-declare-context TheType Parameters Factories Clauses] postulates a
% (section) context with all the mixins provided by the factories and all
% the structure instances we can derive on TheType from these. Clauses
% contain mixin-src for each postulated mixin
pred main-declare-context i:term, i:list term, i:list-w-params factoryname, o:list prop, o:list constant.
main-declare-context TheType TheParams GRFSwP MSL CL :-  std.do! [
  factories-provide GRFSwP MLwP,
  apply-w-params MLwP TheParams TheType MLwAllArgs,
  std.fold MLwAllArgs [] postulate-mixin MSL,
  MSL => declare-instances TheType {findall-classes} CL,
  std.forall MSL (ms\ coq.vernac.accumulate current (clause _ _ ms)),
].

% [main-declare-builder (builder _ F M B) From MoreFrom] Given B of type FB, it
% declares all the new builders F to M via B.
% From holds the (from F Mi Bi) new clauses during folding.
pred main-declare-builder i:builder, i:list prop, o:list prop.
main-declare-builder (builder _ SrcFactory TgtMixin B) FromClauses MoreFromClauses :-
  FromClauses => std.do! [
    if (from SrcFactory TgtMixin _)
       (if-verbose (coq.say "HB: skipping duplicate builder from"
          {nice-gref->string SrcFactory} "to" {nice-gref->string TgtMixin}),
        MoreFromClauses = FromClauses)
       (if-verbose (coq.say "HB: declare builder from"
          {nice-gref->string SrcFactory} "to" {nice-gref->string TgtMixin}),
        MoreFromClauses = [from SrcFactory TgtMixin B|FromClauses])
  ].

% [export Module] exports a Module now adds it to the collection of
% modules to export in the end of the current enclosing module,
% by the command HB.Exports

pred hb.export i:modpath.
hb.export Module :- !,
  coq.vernac.export-module Module,
  coq.vernac.accumulate current (clause _ _ (module-to-export Module)).

pred main-reexport.
main-reexport :- !,
  std.findall (module-to-export Module_) Mods,
  std.forall Mods (x\ sigma y\ module-to-export y = x, coq.vernac.export-module y).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HB.structure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% const Po : forall p1 .. pm T m1 .. mn, Extra  (Eg Extra = forall x y, x + y = y + z)
% const C : forall p1 .. pm s, Extra
% Po P1 .. PM T M1 .. MN PoArgs -> C P1 .. PM S PoArgs
pred clean-op-ty i:list prop, i:term, i:term, o:term.
clean-op-ty [] _ T1 T2 :- copy T1 T2.
clean-op-ty [exported-op _ Po C|Ops] S T1 T2 :-
  gref-deps (const Po) MLwP,
  w-params.nparams MLwP NParams,
  std.length {list-w-params_list MLwP} NMixins,

  (pi L L1 Params Rest PoArgs\
    copy (app [global (const Po)| L]) (app [global (const C) | L1]) :-
      std.split-at NParams L Params [_|Rest],
      std.drop NMixins Rest PoArgs,
      std.append Params [S|PoArgs] L1) =>

  clean-op-ty Ops S T1 T2.

pred operation-body-and-ty i:list prop, i:constant, i:structure, i:term, i:term,
  i:list term, i:term, i:w-args A, o:pair term term.
operation-body-and-ty EXI Poperation Struct Psort Pclass Params _T (triple _ Params _) (pr Bo Ty) :- std.do! [
  mk-app (global Struct) Params StructType,
  mk-app Psort Params PsortP,
  mk-app Pclass Params PclassP,
  Bo = fun `s` StructType Body,
  Ty = prod `s` StructType BodyTy,
  (@pi-decl `s` StructType s\ sigma Carrier Class\ std.do! [
      mk-app PsortP [s] Carrier,
      mk-app PclassP [s] Class,
      under-mixin-src-from-factory.do! Carrier Class [
        % just in case..
        mgref->term Params Carrier (const Poperation) (Body s),
        std.assert-ok! (coq.typecheck (Body s) (DirtyTy s)) "export-1-operation: Body illtyped",
        clean-op-ty EXI s (DirtyTy s) (BodyTy s),
      ],
  ]),
].

% given an operation (a mixin projection) we generate a constant projection the
% same operation out of the package structure (out of the class field of the
% structure). We also provide all the other mixin dependencies (other misins)
% of the package structure.
pred export-1-operation i:mixinname, i:structure, i:term, i:term, i:one-w-params mixinname, i:option constant, i:list prop, o:list prop.
export-1-operation _ _ _ _ _ none EX EX :- !. % not a projection, no operation
export-1-operation M Struct Psort Pclass MwP (some Poperation) EXI EXO :- !, std.do! [
  coq.gref->id (const Poperation) Name,

  w-params.then MwP mk-fun-prod ignore (operation-body-and-ty EXI Poperation Struct Psort Pclass) (pr Body BodyTy),

  if-verbose (coq.say "HB: export operation" Name),
  coq.vernac.add-const Name Body BodyTy @transparent! C,

  w-params.nparams MwP NP,
  NImplicits is NP + 1,
  std.map {std.iota NImplicits} (_\r\ r = maximal) Implicits,
  coq.vernac.set-implicit tt (const C) Implicits,

  EXO = [exported-op M Poperation C|EXI]
].

% Given a list of mixins, it exports all operations in there
pred export-operations.aux i:structure, i:term, i:term, i:one-w-params mixinname, i:list prop, o:list prop.
export-operations.aux Struct ProjSort ProjClass MwP EX1 EX2 :- !, std.do! [
  w-params_1 MwP (indt M),
  coq.CS.canonical-projections M Poperations,
  std.fold Poperations EX1 (export-1-operation (indt M) Struct ProjSort ProjClass MwP) EX2,
].

pred mixin-not-already-declared i:one-w-params mixinname.
mixin-not-already-declared MwP :-
  w-params_1 MwP M, not(mixin-first-class M _), M = indt _.

pred export-operations i:structure, i:term, i:term, i:list-w-params mixinname, i:list prop, o:list prop, o:list mixinname.
export-operations Structure ProjSort ProjClass MLwP EX1 EX2 MLToExport :- std.do! [
  distribute-w-params MLwP LMwP,
  std.filter LMwP mixin-not-already-declared LMwPToExport,
  std.fold LMwPToExport EX1 (export-operations.aux Structure ProjSort ProjClass) EX2,
  std.map LMwPToExport w-params_1 MLToExport,
].

pred mk-coe-class-body
  i:factoryname, % From class
  i:factoryname, % To class
  i:list-w-params mixinname, % To mixins
  i:list term, i:term, % Params, T
  i:list (w-args mixinname),
  o:term.
mk-coe-class-body FC TC TMLwP Params T _ CoeBody :- std.do! [
  mk-app (global FC) {std.append Params [T]} Class,

  list-w-params_list TMLwP TML,
  std.map TML (from FC) Builders,
  std.map Builders (x\r\mk-app (global x) Params r) BuildersP,

  mk-app (global {get-constructor TC})
    {coq.mk-n-holes {factory-nparams TC}} KCHoles,

  (pi c\ sigma Mixes\
    std.map BuildersP (builder\r\ r = app[builder, T, c]) Mixes,
    mk-app KCHoles [T | Mixes] (ClassCoercion c)),

  CoeBody = {{ fun (c : lp:Class) => lp:(ClassCoercion c) }}
].

pred mk-coe-structure-body
  i:structure, % From structure
  i:structure, % To structure
  i:factoryname, % To factory (for nparams)
  i:term, % class coercion
  i:term, % sort projection
  i:term, % class projection
  i:list term, i:term, % Params, T
  i:list (w-args mixinname),
  o:term.
mk-coe-structure-body StructureF StructureT TC Coercion SortProjection ClassProjection
    Params _T _ SCoeBody :- std.do! [

  mk-app (global StructureF) Params StructureP,
  mk-app     SortProjection  Params SortP,
  mk-app     ClassProjection Params ClassP,
  mk-app     Coercion        Params CoercionP,

  mk-app (global {get-constructor StructureT})
    {coq.mk-n-holes {factory-nparams TC}} PackPH,

  SCoeBody = {{ fun s : lp:StructureP =>
     let T : Type := lp:SortP s in
     lp:PackPH T (lp:CoercionP T (lp:ClassP s)) }},
].

% [declare-coercion P1 P2 C1 C2] declares a structure and a class coercion
% from C1 to C2 given P1 P2 the two projections from the structure of C1
pred declare-coercion i:term, i:term, i:class, i:class.
declare-coercion SortProjection ClassProjection
    (class FC StructureF FMLwP) (class TC StructureT TMLwP) :- std.do! [

  coq.vernac.accumulate current (clause _ _ (sub-class FC TC)),

  gref->modname StructureF ModNameF,
  gref->modname StructureT ModNameT,
  CName is ModNameF ^ "_class_to_" ^ ModNameT ^ "_class",
  SName is ModNameF ^ "_to_" ^ ModNameT,

  if-verbose (coq.say "HB: declare coercion" SName),

  w-params.then FMLwP mk-fun mk-fun
    (mk-coe-class-body FC TC TMLwP) CoeBody,

  std.assert-ok! (coq.typecheck CoeBody Ty) "declare-coercion: CoeBody illtyped",

  if-verbose (coq.say "HB: declare coercion hint" CName),

  coq.vernac.add-const CName CoeBody Ty @transparent! C,
  coq.vernac.declare-coercion (coercion (const C) 1 FC (grefclass TC)),

  Coercion = global (const C),
  w-params.then FMLwP mk-fun ignore
    (mk-coe-structure-body StructureF StructureT TC Coercion SortProjection ClassProjection)
    SCoeBody,

  std.assert-ok! (coq.typecheck SCoeBody STy) "declare-coercion: SCoeBody illtyped",

  if-verbose (coq.say "HB: declare unification hint" SName),

  coq.vernac.add-const SName SCoeBody STy @transparent! SC,
  coq.vernac.declare-coercion (coercion (const SC) 0 StructureF (grefclass StructureT)),
  coq.vernac.declare-instance (const SC), % TODO: API in Elpi, take a @constant instead of gref
].

pred join-body i:int, i:int, i:structure, i:term, i:term, i:term, i:term, i:term,
  i:list term, i:name, i:term, i:(term -> A), o:term.
join-body N1 N2 S3 S2_Pack S1_sort S3_to_S1 S2_class S3_to_S2
  P N _Ty _F (fun N S3P Pack) :- !,
  mk-app (global S3) P S3P, !,
  coq.mk-n-holes N2 Holes2, !,
  coq.mk-n-holes N1 Holes1, !,
  @pi-decl N S3P s\
  sigma S3_to_S1_Ps S3_to_S2_Ps S1_sortS3Ps S2_classS3Ps \ std.do! [
    mk-app S3_to_S1 {std.append P [s]} S3_to_S1_Ps,
    mk-app S1_sort {std.append Holes1 [S3_to_S1_Ps]} S1_sortS3Ps,
    mk-app S3_to_S2 {std.append P [s]} S3_to_S2_Ps,
    mk-app S2_class {std.append Holes2 [S3_to_S2_Ps]} S2_classS3Ps ,
    mk-app S2_Pack {std.append Holes2 [S1_sortS3Ps, S2_classS3Ps]} (Pack s)
  ].

pred declare-join i:class, i:pair class class, o:prop.
declare-join (class C3 S3 MLwP3) (pr (class C1 S1 _) (class C2 S2 _)) (join C1 C2 C3) :-
  Name is "join_" ^ {gref->modname S3} ^
    "_between_" ^ {gref->modname S1} ^ "_and_" ^ {gref->modname S2},

  get-structure-coercion S3 S2 S3_to_S2,
  get-structure-coercion S3 S1 S3_to_S1,
  get-structure-sort-projection S1 S1_sort,
  get-structure-class-projection S2 S2_class,
  get-constructor S2 S2_Pack,

  factory-nparams C1 N1,
  factory-nparams C2 N2,

  if-verbose (coq.say "HB: declare unification hint" Name),
  w-params.fold MLwP3 mk-fun (join-body N1 N2 S3
    (global S2_Pack) S1_sort S3_to_S1 S2_class S3_to_S2) JoinBody,
  std.assert-ok! (coq.typecheck JoinBody Ty) "declare-join: JoinBody illtyped",
  coq.vernac.add-const Name JoinBody Ty @transparent! J,
  coq.vernac.declare-instance (const J).

% TODO: this works under the invariant: we never have two classes that
% contain exactly the same mixins. hb.structure should enforce this
% and eventually just alias the existing one rather than failing.
% TODO: hb.structure should check we are not inserting the class
% in the middle of existing ones. Possible fix: always declare all intermediate
% possibilities but without proper names (requires the previous TODO about
% aliasing already existing stuff).
pred declare-unification-hints i:term, i:term, i:class, o:list prop.
declare-unification-hints SortProj ClassProj CurrentClass NewJoins :- std.do! [
  findall-classes All,

  std.filter All (sub-class? CurrentClass) AllSuper,
  std.forall AllSuper (declare-coercion SortProj ClassProj CurrentClass),

  findall-newjoins CurrentClass AllSuper TodoJoins,

  std.map TodoJoins (declare-join CurrentClass) NewJoins
].

% For each mixin we declare a field and apply the mixin to its dependencies
% (that are previously declared fields recorded via field-for-mixin)
pred synthesize-fields i:term, i:list (w-args mixinname), o:record-decl.
synthesize-fields _T []     end-record.
synthesize-fields T  [triple M Args _|ML] (field _ Name MTy Fields) :- std.do! [
  Name is {gref->modname M} ^ "_mixin",
  if-verbose (coq.say "HB: typing class field" M),
  std.assert! (mgref->term Args T M MTy) "anomaly: a field type cannot be solved",
  @pi-decl `m` MTy m\ mixin-src T M m => synthesize-fields T ML (Fields m)
].

pred synthesize-fields.body i:list term, i:term, i:list (w-args mixinname), o:indt-decl.
synthesize-fields.body _Params T ML (record "axioms" {{ Type }} "Class" FS) :-
  synthesize-fields T ML FS.

pred mk-record+sort-field i:name, i:term, i:(term -> record-decl), o:indt-decl.
mk-record+sort-field _ T F (record RecordName {{ Type }} "Pack" (field _ "sort" T F)) :-
  if (get-option "infer" _) (RecordName = "type_") (RecordName = "type").

pred mk-class-field i:classname, i:list term, i:term, i:list (w-args mixinname), o:record-decl.
mk-class-field ClassName Params T _ (field _ "class" (app [global ClassName|Args]) _\end-record) :-
  std.append Params [T] Args.

% Builds the axioms record and the factories from this class to each mixin
pred declare-class+structure i:list-w-params mixinname, o:factoryname, o:structure, o:term, o:term, o:list prop.
declare-class+structure MLwP (indt ClassInd) (indt StructureInd) SortProjection ClassProjection AllFactories :- std.do! [

  if-verbose (coq.say "HB: declare axioms record"MLwP ),

  w-params.then MLwP (mk-parameter explicit) (mk-parameter explicit)
    synthesize-fields.body ClassDeclaration,

  std.assert-ok! (coq.typecheck-indt-decl ClassDeclaration) "declare-class: illtyped",
  coq.vernac.add-indt ClassDeclaration ClassInd,
  coq.CS.canonical-projections ClassInd Projs,
  % TODO: put this code in a named clause
  w-params.nparams MLwP NParams,
  std.map2 {list-w-params_list MLwP} Projs (m\ p\ r\ sigma P\
    p = some P,
    r = from (indt ClassInd) m (const P)) Factories,
  AllFactories = [factory-nparams (indt ClassInd) NParams | Factories],

  if-verbose (coq.say "HB: declare type record"),

  w-params.then MLwP (mk-parameter explicit) mk-record+sort-field
    (mk-class-field (indt ClassInd)) StructureDeclaration,

  std.assert-ok! (coq.typecheck-indt-decl StructureDeclaration) "declare-structure: illtyped",
  coq.vernac.add-indt StructureDeclaration StructureInd,

  coq.CS.canonical-projections StructureInd [some SortP, some ClassP],
  global (const SortP) = SortProjection,
  global (const ClassP) = ClassProjection,

].

% Declares "sort" as a coercion Structurename >-> Sortclass
pred declare-sort-coercion i:structure, i:term.
declare-sort-coercion StructureName (global Proj) :-
  if-verbose (coq.say "HB: declare sort coercion"),
  coq.vernac.declare-coercion (coercion Proj 0 StructureName sortclass).

pred if-class-already-exists-error i:id, i:list class, i:list mixinname.
if-class-already-exists-error _ [] _.
if-class-already-exists-error N [class _ S ML1wP|CS] ML2 :-
  list-w-params_list ML1wP ML1,
  if (list-eq-set ML1 ML2)
     (coq.error "Structure" {nice-gref->string S} "contains the same mixins of" N)
     (if-class-already-exists-error N CS ML2).

pred export-mixin-coercion i:classname, i:option constant.
export-mixin-coercion _ none.
export-mixin-coercion ClassName (some C) :-
  coq.env.typeof (const C) CTy,
  head-gref-under-prods CTy MixinGR,
  if-verbose (coq.say "HB: export class to mixin coercion for mixin" {nice-gref->string MixinGR}),
  coq.vernac.declare-coercion (coercion (const C) _ ClassName (grefclass MixinGR)).

pred mc-compat-structure i:string, i:modpath, i:list mixinname, i:int, i:classname, i:term, i:option gref.
mc-compat-structure ModuleName _Module NewMixins CNParams ClassName ClassProjection Axioms :- std.do! [
  CompatModuleName is "MathCompCompat" ^ ModuleName,
  coq.vernac.begin-module CompatModuleName, % to avoid collisions
  coq.vernac.begin-module ModuleName,

  if (Axioms = some GR)
    (@global! => coq.vernac.add-abbreviation "axiom" 0 (global GR) ff _)
    true,

  if (NewMixins = [NewMixin]) (std.do! [
    if-verbose (coq.say "mc-compat-structure: declaring notations 'axioms', 'mixin_of' and 'Mixin'"),
    MArgs is {factory-nparams NewMixin} + 1,
    mk-eta MArgs {coq.env.typeof NewMixin} (global NewMixin) EtaNewMixin,
    @global! => coq.vernac.add-abbreviation "axioms" MArgs EtaNewMixin ff _,
    @global! => coq.vernac.add-abbreviation "mixin_of" MArgs EtaNewMixin ff _,
    std.assert! (factory-constructor NewMixin FK) "BUG: Factory constructor missing",
    std.assert! (phant-abbrev FK _ PhAbb) "BUG: missing phant-abbrev",
    @global! => coq.vernac.add-abbreviation "Mixin" 0
      {coq.notation.abbreviation PhAbb {coq.mk-n-holes MArgs}} ff _,
    if-verbose (coq.say "mc-compat-structure: declaring pack abbreviation"),
    class-def (class ClassName _ ClassMixins),
    w-params.then ClassMixins mk-fun mk-fun (pack-body ClassName) Pack,
    coq.vernac.add-const "pack_" Pack _ @transparent! GRPack,
    (phant-mixin-real NewMixin => gref-deps (const GRPack) ClassMixins => mk-phant-abbrev "pack" {mk-phant-term (const GRPack)} _ _),
    ])
    (if-verbose (coq.say "mc-compat-structure: not exactly one new mixin")),

  if-verbose (coq.say "mc-compat-structure: declaring notation 'class_of'"),
  std.assert-ok! (coq.typecheck ClassProjection ClassProjectionTy) "wtf",
  CArgs is CNParams + 1,
  mk-eta CArgs ClassProjectionTy ClassProjection EtaClassProjection,
  @global! => coq.vernac.add-abbreviation "class_of" CArgs EtaClassProjection ff _,

  coq.vernac.end-module ModuleName _,
  coq.vernac.end-module CompatModuleName MCCompat,
  coq.vernac.export-module MCCompat,
  %coq.env.import-module Module,
].

pred clone-phant-body i:factoryname, i:term, i:structure, i:list term, i:term, i:list (w-args mixinname), o:phant-term.
clone-phant-body ClassName SortProjection ((indt I) as Structure) PL T _ PhF :- std.do! [
  std.assert! (coq.env.indt I _ _ _ _ [PackC] _) "wtf",
  mk-app (global (indc PackC)) {std.append PL [T]} PackPLT,
  mk-app (global Structure) PL SPL,
  (@pi-decl `cT` SPL cT\
  mk-app (global ClassName) {std.append PL [T]} CPL,
  @pi-decl `c` CPL c\
  (Ph cT c) =
    {phant-fun-unify {{lib:hb.nomsg}} T {mk-app {mk-app SortProjection PL} [cT]}
      {phant-fun-unify {{lib:hb.nomsg}} cT {mk-app PackPLT [c]}
        (phant-term [] {mk-app PackPLT [c]}) }}),
  PhF = {phant-fun-real `cT` SPL cT\ {phant-fun-implicit `c` CPL c\ Ph cT c }}
].

% [pack-body ClassName P T MLwA B] asserts
%  B = fun m0 ... mn => Pack P T (Class P T m0 ... mn)
% under a context with P and T
pred pack-body.mixins i:list term, i:term, i:gref, i:gref, o:term.
pack-body.mixins PL T BuildC PackS Body :- !, std.do! [
  mgref->term PL T BuildC Class,
  mk-app (global PackS) {std.append PL [T, Class]} Body
].

pred pack-body i:classname, i:list term, i:term, i:list (w-args mixinname), o:term.
pack-body ClassName PL T MLwA F :- std.do! [
  class-def (class ClassName S _),
  get-constructor ClassName BuildC,
  get-constructor S PackS,
  under-mixins.then MLwA mk-fun (pack-body.mixins PL T BuildC PackS) F
].

pred declare-auto-infer-params-abbrev i:structure, i:list-w-params mixinname.
declare-auto-infer-params-abbrev GR MLwP :- get-option "infer" Map, !,
  Map => mk-infer (global GR) MLwP PHT,
  mk-phant-abbrev "type" PHT _ _.
declare-auto-infer-params-abbrev _ _.

pred mk-infer i:term, i:list-w-params mixinname, o:phant-term.
mk-infer T (w-params.nil _ _ _) (phant-term [] T).
mk-infer T (w-params.cons N Ty W) (phant-term [implicit-arg, infer-type N|A] R1) :-
  coq.name->id N ID, (get-option ID "Type" ; get-option ID ""), !,
  R1 = (fun N Ty n\ fun `ph` {{ lib:@hb.phant lp:n }} _\ R n),
  @pi-decl N Ty n\
    mk-infer {mk-app T [n]} (W n) (phant-term A (R n)).
mk-infer T (w-params.cons N Ty W) (phant-term [real-arg N|A] (fun N Ty R)) :-
   coq.name->id N ID, not (get-option ID _), !,
  @pi-decl N Ty x\  mk-infer {mk-app T [x]} (W x) (phant-term A (R x)).
mk-infer _ (w-params.cons N _ _) _ :- coq.name->id N ID, get-option ID Infer,
  coq.error "Automatic inference of paramter" N "from" Infer "not supported".

% HB.structure Definition S P1 P2 := { T of F1 P1 T & F2 P1 (P2*P2) T }
%  cons p1\ cons p2\ nil t\ [triple f1 [p1] t,triple f2 [p1, {{p1 * p2}}] t]
pred main-declare-structure i:string, i:list-w-params gref, i:bool.
main-declare-structure Module GRFSwP ClosureCheck :- std.do! [
  factories-provide GRFSwP PMLwP,

  list-w-params.flatten-map GRFSwP gref-deps RMLwP, % TODO: extract code from factories-provide
  list-w-params.append PMLwP RMLwP UnsortedMLwP,
  w-params.map UnsortedMLwP (p\t\ toposort-mixins) MLwP,

  list-w-params_list PMLwP PML,
  list-w-params_list MLwP ML,

  if (ClosureCheck = tt, not({std.length PML} = {std.length ML}))
     (coq.warn "HB: pulling in dependencies:" {std.map {list-diff ML PML} nice-gref->string}
               "\nPlease list them or end the declaration with '&'")
     true,

  if-class-already-exists-error Module {findall-classes} ML,
  if-coverage-not-good-error ML,

  % TODO: check we never define the superclass of an exising class

  if-verbose (coq.say "HB: start module" Module),

  coq.vernac.begin-module Module,

  declare-class+structure MLwP
    ClassName Structure SortProjection ClassProjection Factories,

  w-params.map MLwP (_\_\_\ mk-nil) NilwP,
  ClassAlias = (factory-alias->gref ClassName ClassName),
  CurrentClass = (class ClassName Structure MLwP),
  ClassName = indt ClassInd, coq.env.indt ClassInd _ _ _ _ [ClassK] _,
  GRDepsClauses = [gref-deps (indt ClassInd) NilwP, gref-deps (indc ClassK) MLwP],
  
  declare-auto-infer-params-abbrev Structure MLwP,

  if-verbose (coq.say "HB: declaring clone abbreviation"),

  w-params.then MLwP phant-fun-real phant-fun-real
    (clone-phant-body ClassName SortProjection Structure) PhClone,

  mk-phant-abbrev "clone" PhClone _ _,

  if-verbose (coq.say "HB: start module Exports"),

  if-arg-sort (
    if-verbose (coq.say "HB: define arg_sort"),
    std.assert-ok! (coq.typecheck SortProjection SortProjTy)
      "HB: BUG: cannot retype projection",
    coq.vernac.add-const "arg_sort" SortProjection SortProjTy ff ArgSortCst
  ),

  coq.vernac.begin-module "Exports",
  if-arg-sort (declare-sort-coercion Structure (global (const ArgSortCst))),
  declare-sort-coercion Structure SortProjection,

  if-verbose (coq.say "HB: exporting unification hints"),
  ClassAlias => Factories => GRDepsClauses =>
    declare-unification-hints SortProjection ClassProjection CurrentClass NewJoins,
  % Register in Elpi's DB the new structure
  % NOT TODO: All these acc are correctly locaed in an Export Module

  if (ClassName = indt ClassInd) (std.do![
    if-verbose (coq.say "HB: exporting coercions from class to mixins"),
    std.forall {coq.CS.canonical-projections ClassInd}
      (export-mixin-coercion ClassName)
    ])
    (coq.say "declare-structure:" ClassName "should be an inductive", fail),

  if-verbose (coq.say "HB: accumulating various props"),
  std.flatten [
      Factories, [ClassAlias], [is-structure Structure],
      NewJoins, [class-def CurrentClass], GRDepsClauses
    ]
    NewClauses,
  std.forall NewClauses (c\ coq.vernac.accumulate current (clause _ _ c)),

  if-verbose (coq.say "HB: stop module Exports"),
  coq.vernac.end-module "Exports" Exports,

  coq.vernac.end-module Module ModulePath,

  if-verbose (coq.say "HB: end modules; export" Exports),

  hb.export Exports,

  if-verbose (coq.say "HB: exporting operations"),
    ClassAlias => Factories => GRDepsClauses =>
      export-operations Structure SortProjection ClassProjection MLwP [] EX   MLToExport,
    % TODO: issue an Arguments op T : rename, where T is the name written by
    %   the user in Definition foo := { T of ... }

  if-verbose (coq.say "HB: operations meta-data module: ElpiOperations"),

  ElpiOperationModName is "ElpiOperations" ^ {std.any->string {new_int}},
  coq.vernac.begin-module ElpiOperationModName,
    std.map MLToExport (m\r\ r = mixin-first-class m ClassName) MixinFirstClass,
    std.forall {std.append EX MixinFirstClass} (c\ coq.vernac.accumulate current (clause _ _ c)),
  coq.vernac.end-module ElpiOperationModName ElpiOperations,
  hb.export ElpiOperations,

  if-verbose (coq.say "HB: abbreviation factory-by-classname"),

  NewClauses => declare-factory-abbrev Module (factory-by-classname ClassName),

  NewClauses => if-MC-compat (mc-compat-structure Module ModulePath MLToExport {w-params.nparams MLwP} ClassName ClassProjection),

].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HB.builders
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred declare-old-located i:string, i:located.
declare-old-located Id (loc-gref GR) :-
  @global! => coq.vernac.add-abbreviation Id 0 (global GR) ff _.
declare-old-located Id (loc-abbreviation Abbrev) :-
  coq.notation.abbreviation Abbrev [] T,
  % FIXME: this assumes the abbreviation has no arg
  % we should fix it.
  @global! => coq.vernac.add-abbreviation Id 0 T ff _.

pred declare-old-constant i:option constant.
declare-old-constant none.
declare-old-constant (some C) :-
  coq.gref->id (const C) Id,
  std.forall {coq.locate-all Id} (declare-old-located Id).
declare-old-constant _ :- true.

pred elaborate-context-skel->factory i:context-decl, o:context-decl, o:factoryname, o:diagnostic.
elaborate-context-skel->factory
  (context-item IDT IT TTySkel none t\ context-item IDF IF (TFSkel t) none _\ context-end)
  (context-item IDT IT TTy none t\ context-item IDF IF (TFSkel t) none _\ context-end) GRF Diag
:- !, std.do-ok! Diag [
  coq.elaborate-ty-skeleton TTySkel _ TTy,
  (d\ coq.id->name IDT NameT),
  (d\ @pi-decl NameT TTy t\ purge-id (TFSkel t) (TFSkel1 t), coq.elaborate-ty-skeleton (TFSkel1 t) _ (TF1 t) d),
  (d\ @pi-decl NameT TTy t\ std.assert! (factory? (TF1 t) (triple GRF _Params t)) "the last argument must be a factory applied to the type variable"),
].
elaborate-context-skel->factory (context-item ID I TSkel none C) (context-item ID I T none C1) GRF Diag :- !, std.do-ok! Diag [
  coq.elaborate-ty-skeleton TSkel _ T,
  (d\ coq.id->name ID Name),
  (d\ @pi-decl Name T x\ elaborate-context-skel->factory (C x) (C1 x) GRF d),
].
elaborate-context-skel->factory (context-item ID _ _ (some _) _) _ _ _ :-
  coq.error "context item cannot be given a body:" ID.

pred purge-id i:term, o:term.
purge-id T T1 :-
  (pi fresh t v\ copy {{lib:@hb.id lp:t lp:v}} fresh :- !) => copy T T1.

pred postulate-factory-abbrev i:term, i:list term, i:id, i:factoryname, o:term.
postulate-factory-abbrev TheType Params Name Falias TheFactory :- std.do! [
  factory-alias->gref Falias F,
  phant-abbrev F _ Fabv,
  coq.notation.abbreviation Fabv {std.append Params [TheType]} Package,
  Msg is "Unable to declare factory " ^ Name,
  std.assert-ok! (coq.typecheck-ty Package _) Msg,
  coq.vernac.add-variable Name Package C,
  TheFactory = global (const C),
].

% Only record fields can be exported as operations.
pred define-factory-operations i:term, i:list term, i:term, i:gref.
define-factory-operations TheType Params TheFactory (indt I) :- !,
  coq.env.indt I _ NIParams _ _ _ _,
  NHoles is NIParams - 1 - {std.length Params},
  coq.CS.canonical-projections I PL,
  std.forall PL (define-factory-operation TheType Params TheFactory NHoles).
define-factory-operations _ _ _ _.

pred define-factory-operation i:term, i:list term, i:term, i:int, i:option constant.
define-factory-operation _ _ _ _ none.
define-factory-operation TheType Params TheFactory NHoles (some P) :-
  coq.mk-n-holes NHoles Holes,
  std.append Holes [TheFactory] Holes_Factory,
  std.append Params [TheType|Holes_Factory] Args,
  T = app[global (const P)|Args],
  std.assert-ok! (coq.typecheck T _) "Illtyped applied factory operation",
  coq.gref->id (const P) Name,
  @local! => coq.vernac.add-abbreviation Name 0 T ff _.

pred fresh-type o:term.
fresh-type Ty :-
  Ty = {{Type}},
  std.assert-ok! (coq.typecheck-ty Ty _) "impossible".

pred builders-postulate-factories i:id, i:context-decl.
builders-postulate-factories ModName (context-item IDT _ TySkel none t\ context-item IDF _ (TF t) none _\ context-end) :- !, std.do! [
  % TODO we should allow T to be anything.
  std.assert-ok! (coq.elaborate-ty-skeleton TySkel _ Ty) "builders-postulate-factory: illtyped context",
  if (var Ty) (fresh-type Ty)
     (std.assert-ok! (coq.unify-eq Ty {{Type}}) "The last context item before the factory must be a type variable"),
  if-verbose (coq.say "HB: postulating type" IDT),
  coq.vernac.add-variable IDT Ty C,
  TheType = global (const C),

  std.assert! (factory? (TF TheType) (triple GRF Params TheType))
    "the last argument must be a factory applied to the type variable",
  gref-deps GRF GRFMLwP, % TODO: remove, pass to main-declare-context the list-w-params-eta-expansion of GRF
  main-declare-context TheType Params GRFMLwP _ _,
  postulate-factory-abbrev TheType Params IDF GRF TheFactory,
  define-factory-operations TheType Params TheFactory GRF,
  coq.vernac.accumulate current (clause _ _ (current-mode (builder-from TheFactory GRF ModName))),
].

builders-postulate-factories ModName (context-item ID _ TSkel none Factories) :- std.do! [
  if-verbose (coq.say "HB: postulating" ID),
  std.assert-ok! (coq.elaborate-ty-skeleton TSkel _ T) "builders-postulate-factories: illtyped context",
  if (var T) (coq.fresh-type T) true,
  coq.vernac.add-variable ID T P,
  TheParam = global (const P),
  builders-postulate-factories ModName (Factories TheParam),
].

builders-postulate-factories _ (context-item ID _ _ (some _) _) :-
  coq.error "context item cannot be given a body:" ID.

pred main-begin-declare-builders i:context-decl.
main-begin-declare-builders CtxSkel :- std.do! [
  Name is "Builders_" ^ {term_to_string {new_int}}, % TODO?
  std.assert-ok! (elaborate-context-skel->factory CtxSkel Ctx GRF) "Context illtyped",
  if-verbose (coq.say "HB: context to factory"),
  coq.vernac.begin-module Name,
  if-verbose (coq.say "HB: begin module for builders"),
  if (GRF = indt FRecord) (std.do! [
    if-verbose (coq.say "HB: begin module Super"),
    coq.vernac.begin-module "Super",
    std.forall {coq.CS.canonical-projections FRecord} declare-old-constant,
    coq.vernac.end-module "Super" _,
    if-verbose (coq.say "HB: ended module Super")]) (true),
  coq.vernac.begin-section Name,
  if-verbose (coq.say "HB: postulating factories"),
  builders-postulate-factories Name Ctx,
].

/* HB.context?
pred main-begin-declare i:string, i:string, i:list gref, i:declaration.
main-begin-declare Module TName GRFS Decl :- std.do! [

  if-verbose (coq.say "HB: start module and section" Module),

  coq.vernac.begin-module Module none,
  coq.vernac.begin-section Module,

  if-verbose (coq.say "HB: postulate type" TName),

  coq.fresh-type Ty,
  @local! => coq.vernac.add-const TName _ Ty @opaque! T, % no body, local -> a variable
  main-declare-context (global (const T)) [] GRFS _, % TODO params
  coq.vernac.accumulate current (clause _ _ (current-mode Decl))
].
*/

pred main-end-declare-builders.
main-end-declare-builders :- std.do! [
  current-mode (builder-from _ GR ModName),

  coq.vernac.end-section ModName,

  findall-builders LFIL,

  std.fold LFIL [] main-declare-builder Clauses,

  if (Clauses = [])
     (coq.error "No builders to declare, did you forget HB.instance?")
     true,

  % TODO: Do we need this module?
  gref->modname GR M,
  Name is M ^ "_Exports",
  coq.vernac.begin-module Name,
  (std.forall Clauses c\ coq.vernac.accumulate current (clause _ _ c)),

  coq.vernac.end-module Name Exports,
  coq.vernac.end-module ModName _,
  hb.export Exports,
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HB.mixin/factory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% [main-declare-asset Asset AssetKind] unifies the code paths for
% mixins, factories (and alias factories)
pred main-declare-asset i:asset-decl, i:asset.
main-declare-asset Asset AssetKind :- std.do! [
  name-of-asset-decl Asset Module,

  if-verbose (coq.say "HB: start module and section" Module),

  coq.vernac.begin-module Module,
  coq.vernac.begin-section Module,

  % We start by postulating the parameters
  process-asset-named-parameters Asset AssetKind Module [],
].

% In an asset like HB.mixing Recoord P1 .. PN A of F1 .. & FK ..
% we call "named" P1 .. PN A, hence A is the last named asset param
pred is-last-named-asset-param i:asset-decl.
is-last-named-asset-param (asset-parameter ID _ _) :- get-option "key" ID, !.
is-last-named-asset-param (asset-parameter _ _ p\ asset-parameter _ (M p) _) :- pi p\ factory? (M p) _, !.
is-last-named-asset-param (asset-parameter _ _ _\ asset-record _ _ _ _) :- !.
is-last-named-asset-param (asset-parameter _ _ _\ asset-alias _ _) :- !.

pred process-asset-named-parameters i:asset-decl, i:asset, i:id, i:list (triple id term term).
% We reached TheType
process-asset-named-parameters (asset-parameter Name T Rest as R) D Module Params :- is-last-named-asset-param R, !, std.do! [

  if-verbose (coq.say "HB: postulate type" Name),
  if (var T) (fresh-type Ty) (Ty = T),
  coq.vernac.add-variable Name Ty C,

  TheType = global (const C),
  % We postulate the dependencies
  process-asset-unnamed-parameters (Rest TheType) [] Module TheType D {std.rev Params}
].
% This is a real parameter, we postulate it
process-asset-named-parameters (asset-parameter Name T Rest) D Module Params :- std.do! [
  std.assert-ok! (coq.typecheck-ty T _) "Illtyped parameter",
  if-verbose (coq.say "HB: postulate " Name),
  if (var T) (coq.fresh-type T) true,
  coq.vernac.add-variable Name T C,
  TheParam = global (const C),
  process-asset-named-parameters (Rest TheParam) D Module [triple Name TheParam T|Params],
].

pred process-asset-unnamed-parameters
  i:asset-decl, i:list (w-args factoryname), i:id, i:term, i:asset, i:list (triple id term term).
process-asset-unnamed-parameters (asset-parameter _ T Rest) FS Module TheType D Params :- std.do! [
  std.assert! (factory? T (triple F Ps TheType)) "Not a factory applied to the type variable",
  std.assert! (pi x y\ Rest y = Rest x) "Factories cannot be explicitly mentioned in the mixin",
  Dummy = sort prop,
  process-asset-unnamed-parameters (Rest Dummy) [triple F Ps TheType|FS] Module TheType D Params,
].

process-asset-unnamed-parameters (asset-alias _ Ty) GRFS Module TheType D Params :- std.do! [
  std.assert! (D = asset-factory) "Mixins cannot be aliases",
  build-list-w-params Params  TheType {std.rev GRFS} GRFSwParams,
  declare-factory-alias Ty GRFSwParams Module TheType {std.map Params triple_2},
].

process-asset-unnamed-parameters (asset-record _ Sort _ Fields) GRFS Module TheType D Params :- std.do! [
  build-list-w-params Params  TheType {std.rev GRFS} GRFSwParams,
  declare-mixin-or-factory Sort Fields GRFSwParams Module TheType D {std.map Params triple_2},
].

pred declare-factory-alias i:term, i:list-w-params factoryname, i:id, i:term, i:list term.
declare-factory-alias Ty1Skel GRFSwP Module TheType TheParams :- std.do! [

  % TODO maybe main-declare-context should just take GRFSwP and postulate
  % the parameters and the type
  main-declare-context TheType TheParams GRFSwP Hyps _,

  std.assert-ok! (coq.elaborate-ty-skeleton Ty1Skel _ Ty1) "Illtyped alias factory",
  coq.vernac.add-const "axioms_" Ty1 _ @transparent! C,

  std.assert! (safe-dest-app Ty1 (global PhF) _Args) "Argument must be a factory",
  std.assert! (factory-alias->gref PhF F) "BUG: Factory alias declaration missing",
  std.assert! (factory-constructor F FK) "BUG: Factory constructor missing",

  Hyps => mgref->term TheParams TheType FK MFK,
  std.assert-ok! (coq.typecheck MFK MFKTy) "BUG: typecking of former factory constructor failed",
  (pi Args\ copy (app [global F|Args]) (global (const C))) => copy MFKTy MFKTyC,
  coq.vernac.add-const "Axioms_" MFK MFKTyC @transparent! CK,
  GRK = const CK,

  coq.vernac.end-section Module,

  coq.vernac.set-implicit tt GRK [],

  factories-provide GRFSwP MLwP,
  GRDepsClauses = [gref-deps (const C) MLwP, gref-deps (const CK) MLwP],

  GRDepsClauses => mk-phant-term GRK PhGRK0,

  if (mixin-first-class F _) (PhGRK = PhGRK0) (append-phant-unify PhGRK0 PhGRK),
  GRDepsClauses => mk-phant-abbrev "Build" PhGRK BuildConst _,

  GRDepsClauses => mk-factory-abbrev "axioms" (const C) Clauses FactAbbrev,

  if-verbose (coq.say "HB: start module Exports"),

  coq.vernac.begin-module "Exports",
  std.forall Clauses (c\ coq.vernac.accumulate current (clause _ _ c)),
  std.forall GRDepsClauses (c\ coq.vernac.accumulate current (clause _ _ c)),
  % std.map {gr-deps GRK} (_\ r\ r = maximal) Implicits,
  % coq.vernac.set-implicit tt GRK [maximal|Implicits],
  w-params.nparams MLwP NParams,
  coq.vernac.accumulate current (clause _ _ (factory-nparams (const C) NParams)),
  coq.vernac.accumulate current (clause _ _ (factory-constructor (const C) GRK)),
  coq.vernac.accumulate current (clause _ _ (factory-builder-nparams BuildConst NParams)),
  coq.vernac.end-module "Exports" Exports,
  coq.vernac.end-module Module _,

  if-verbose (coq.say "HB: end modules and sections; export" Exports),

  hb.export Exports,

  GRDepsClauses => declare-factory-abbrev Module FactAbbrev,
].

% [build-deps-for-projections I ML CL] builds a [gref-dep] for each projection P
% of I such that P depends on "ML @ [I]" (each operation depends on the the
% deps of the record plus the record itself)
pred build-deps-for-projections i:inductive, i:list-w-params mixinname, o:list prop.
build-deps-for-projections R MLwP CL :- std.do! [
  map-filter {coq.CS.canonical-projections R} (x\y\x = some y) MixinOps,
  list-w-params.rcons MLwP (pl\t\r\ r = triple (indt R) pl t) MLRwP,
  std.map MixinOps (gr\r\ r = gref-deps (const gr) MLRwP) CL,
].

% Section handling in Coq is smart, in the sense it it only abstracts over
% variables that aoccur. We don't want that for mixin/factories, so we implement
% our own discharging. Note that definitions (like canonical instance) have
% to be abstracted too.
pred abstract-indt-decl-over-section i:list term, i:term, i:list prop, i:list constant, i:indt-decl, o:indt-decl.
abstract-indt-decl-over-section TheParams TheType MixinSrcClauses SectionCanonicalInstance RDecl RDeclClosed :-
  % compute section variables to be used for discharging
  std.map MixinSrcClauses mixin-src_src Mixins,
  std.append TheParams [TheType|{std.rev Mixins}] Section,
  std.map Section (x\r\ x = global (const r)) SectionVars,
  % We discharge by hand the record declaration so that we can be sure all
  % parameters and mixins are abstracted (even if unused).
  copy-clauses-for-unfold SectionCanonicalInstance CopyUnfold,
  CopyUnfold => abstract-indt-decl SectionVars RDecl RDeclClosed.

pred declare-mixin-or-factory i:term, i:record-decl, i:list-w-params factoryname, i:id, i:term, i:asset, i:list term.
declare-mixin-or-factory Sort1 Fields GRFSwP Module TheType D TheParams :- std.do! [
  main-declare-context TheType TheParams GRFSwP MixinSrcClauses SectionCanonicalInstance,

  if-verbose (coq.say "HB: declare record axioms_"),

  Kname = "Axioms_",
  RDeclSkel = record "axioms_" Sort1 Kname Fields,
  std.assert-ok! (coq.elaborate-indt-decl-skeleton RDeclSkel RDecl) "record declaration illtyped",

  abstract-indt-decl-over-section TheParams TheType MixinSrcClauses SectionCanonicalInstance RDecl RDeclClosed,

  coq.vernac.add-indt RDeclClosed R,
  coq.vernac.end-section Module, % We need to anyway declare the record inside the section
    % since closing the section purges the unused universe level we may have
    % allocated by typechecking the skeleton just above

  coq.env.indt R tt _ _ _ [K] _,
  GRK = indc K,
  coq.vernac.set-implicit tt (indt R) [],
  coq.vernac.set-implicit tt GRK [],

  factories-provide GRFSwP MLwP,
  w-params.nparams MLwP NParams,
  build-deps-for-projections R MLwP GRDepsClausesProjs,
  GRDepsClauses = [gref-deps (indt R) MLwP, gref-deps (indc K) MLwP|GRDepsClausesProjs],

  % TODO: should this be in the Exports module?
  if-verbose (coq.say "HB: declare notation axioms"),

  GRDepsClauses => mk-phant-term GRK PhGRK,

  if-verbose (coq.say "HB: declare notation Axioms"),

  GRDepsClauses => mk-phant-abbrev "Build" PhGRK BuildConst BuildAbbrev,

  if (D = asset-mixin)
     (GRDepsClauses => mk-factory-abbrev "axioms" (indt R) FRClauses FactAbbrev,
      GRDepsClauses => FRClauses => declare-id-builder (indt R) IdBuilderClause,
      Clauses = [IdBuilderClause|FRClauses])
     (GRDepsClauses => mk-factory-abbrev "axioms" (indt R) Clauses FactAbbrev),

  if-verbose (coq.say "HB: start module Exports"),

  coq.vernac.begin-module "Exports",
  std.forall Clauses (c\ coq.vernac.accumulate current (clause _ _ c)),
  std.forall GRDepsClauses (c\ coq.vernac.accumulate current (clause _ _ c)),
  coq.vernac.accumulate current (clause _ _ (factory-nparams (indt R) NParams)),
  std.map {list-w-params_list MLwP} (_\ r\ r = maximal) Implicits,
  coq.vernac.set-implicit tt GRK [maximal|Implicits],
  coq.vernac.accumulate current (clause _ _ (factory-constructor (indt R) GRK)),
  coq.vernac.accumulate current (clause _ _ (factory-builder-nparams BuildConst NParams)),
  coq.vernac.accumulate current (clause _ _ (phant-abbrev GRK (const BuildConst) BuildAbbrev)),
  coq.vernac.end-module "Exports" Exports,
  coq.vernac.end-module Module _,

  if-verbose (coq.say "HB: end modules and sections; export" Exports),

  hb.export Exports,

  GRDepsClauses => declare-factory-abbrev Module FactAbbrev,
].
